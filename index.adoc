= Fuzzy-CSV
:toc: left
:source-highlighter: coderay
:toclevels: 4
FuzzyCSV is a lightweigt groovy data processing library that helps in shaping and cleaning your dataset before its consumed by another service.

== Get FuzzyCsv

FuzzyCsv is published to both maven central and jitpack.io.
Starting from 1.7.1 all versions of FuzzyCSV will be published to maven central

=== Get FuzzyCsv from Maven Central

For maven add the dependency to your pom file like this

Maven

[source,xml]
----
<dependency>
     <groupId>io.github.kayr</groupId>
     <artifactId>fuzzy-csv</artifactId>
     <version>${version}</version>
</dependency>
----

Gradle:

[source,groovy]
----
 compile 'io.github.kayr:fuzzy-csv:${version}'
----

=== Get FuzzyCsv from jitpack.io

The to get artefacts from jipack the name space changes from `io.github.kayr` to `com.github.kayr`.

For Maven

[source,xml]
-----

    ...
    <!-- Add this Repository -->
    <repositories>
        <repository>
            <id>jitpack.io</id>
            <url>https://jitpack.io</url>
        </repository>
    </repositories>
    ...
    <dependency>
            <groupId>com.github.kayr</groupId>
            <artifactId>fuzzy-csv</artifactId>
            <version>${version}</version>
    </dependency>
    ...
-----

For Gradle

[source,groovy]
-----
repositories {
    /* Add this repository */
    maven { url 'https://jitpack.io' }
}

dependencies{
    ...
    compile 'com.github.kayr:fuzzy-csv:${version}'
    ...
}
-----

=== Illustrations

==== Loading Data into Fuzzy-CSV

[source,groovy]
----
include::samples/loading.groovy[tag=code]
----

==== Visualize json data in a console grid table

You can convert json text to a grid console table.

[source,groovy]
----
include::samples/gridify.groovy[tag=code]

//Notice how it merged [first name] and [ferts nama]
//-----------------
//[raw:gridify]
----


==== Merging with a fuzzy match

1. Set the accuracy threshold to 75%
2. Merge using code below

[source,groovy]
----
include::samples/merging.groovy[tag=code]

//[raw:merging]
----



Notice how it merged *_[first name]_* and *_[ferts nama]_*

=== Joins

==== Inner join

[source,groovy]
----
include::samples/join-inner.groovy[tag=code]

//[raw:join-inner]
----


==== Left Join

[source,groovy]
----
include::samples/join-left.groovy[tag=code]

//[raw:join-left]
----


==== Right Join

[source,groovy]
----
include::samples/join-right.groovy[tag=code]

//[raw:join-right]
----


==== Full Join

[source,groovy]
----
include::samples/join-full.groovy[tag=code]

//[raw:join-full]
----
==== Join With Custom Function
[source,groovy]
----
include::samples/join-customfunction.groovy[tag=code]

//[raw:join-customfunction]
----

=== Record Functions

These Help you write expression or functions for a record. E.g A function multiplying price by quantity. The record function run in two modes:

- One with type coercion which can be created using `RecordFx.fn{}`.This mode is lenient and does not throw most exceptions. This mode supports division of nulls(`null/2`), zero(`2/0`) division and type coercion(`"2"/2 or Object/null`) . This mode adds extra overhead and is much slower if your are dealing with lots of records.
- Another mode is `RecordFx.fx{}` which uses the default groovy evaluator. This mode is much faster if you are working with lots of records. However, this mode is not lenient and hence can throw `java.lang.ArithmeticException: Division by zero`. If you want to enable leniency but still want to use the faster `RecordFx.fx{}` you can wrap your code in the `fuzzycsv.FxExtensions` category(e.g `use(FxExtensions){ ...code here.. }`) So the category is registered only once as compared to the former where the category is reqistered on each and every evaluation.


==== Doing a Select with a calculated field

To shoe the difference of how `Record.fx` and `Record.fn`  observe the output of the following code snippet
[source,groovy]
----
include::samples/select-with-function.groovy[tag=code]

//[raw:select-with-function]
----